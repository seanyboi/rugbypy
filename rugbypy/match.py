"""Fetch match stats for individual games."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/match.ipynb.

# %% auto #0
__all__ = ['T', 'fetch_all_matches', 'fetch_matches_by_date', 'fetch_match_details', 'fetch_match_players_stats', 'fetch_matches']

# %% ../nbs/match.ipynb #c21c5238
import pandas as pd
from concurrent.futures import Future, ThreadPoolExecutor, as_completed
from concurrent.futures import TimeoutError as FuturesTimeoutError
from typing import Any, TypeVar

from .team import fetch_team_stats
from .player import fetch_player_stats

# Type variable for generic return types
T = TypeVar("T")

# %% ../nbs/match.ipynb #4b9ac99f
def fetch_all_matches():
    """Fetches all match information that exists: \n
    * match_id \n
    * home_team \n
    * away_team \n
    * date
    """

    try:
        print("Fetching all matches...")
        date_url = "https://raw.githubusercontent.com/seanyboi/rugbydata/main/data/v3/match/match_registry.parquet"
        matches = pd.read_parquet(date_url, engine="pyarrow").sort_values(
            by="date", ascending=True
        )
        return matches
    except Exception as e:
        print(
            f"No match information either because no matches took place or rugbypy does not have access to the match data - {e}. Please raise an issue if neither."
        )

# %% ../nbs/match.ipynb #3444e2a5
def fetch_matches_by_date(date: str):
    """Fetches all match information on a particular date in the format YYYYMMDD that includes: \n
    * match_id \n
    * competition_id \n
    * home_team_id \n
    * home_team_name \n
    * away_team_id \n
    * away_team_name \n
    """

    try:
        print(f"Fetching matches on date: {date}...")
        date_url = f"https://raw.githubusercontent.com/seanyboi/rugbydata/main/data/v3/dates/{date}.parquet"
        matches = pd.read_parquet(date_url, engine="pyarrow")
        return matches
    except Exception as _:
        print(
            f"No match information for matches played on {date} either because no matches took place or rugbypy does not have access to the match data. Please raise en issue if neither."
        )

# %% ../nbs/match.ipynb #7ef1b6bf
def fetch_match_details(match_id: str):
    """Fetches match data for a certain match_id"""
    print(f"Fetching match details for match_id: {match_id}...")
    try:
        match_url = f"https://raw.githubusercontent.com/seanyboi/rugbydata/main/data/v3/match/{match_id}.parquet"
        matches = pd.read_parquet(match_url, engine="pyarrow")
        return matches
    except Exception as _:
        print("Error fetching match data. Please raise an issue!")

# %% ../nbs/match.ipynb #4e14d573
def fetch_match_players_stats(match_id: str, max_workers: int = 1) -> pd.DataFrame:
    """Fetches player statistics for all players who participated in a specific match. \n
    Uses parallel processing to efficiently fetch stats for all players from both teams. \n

    Args:
        match_id (str): The unique identifier for the match
        max_workers (int): Number of parallel workers for fetching player stats (default: 1)

    Returns:
        pd.DataFrame: Combined DataFrame with statistics for all players in the match,
                     or empty DataFrame if no data available
    """

    def get_list_of_players(team_id: str, match_id: str):
        """Extracts the list of unique players for a team in a specific match.

        Args:
            team_id (str): The unique identifier for the team
            match_id (str): The unique identifier for the match

        Returns:
            list: List of unique player IDs, or empty list if no data found
        """
        team_stats = fetch_team_stats(team_id=team_id)
        try:
            players = set(
                team_stats[team_stats["match_id"] == match_id]["players"].iloc[0]
            )
            list_players = list(players)
            return list_players

        except Exception as _:
            print("No player data found for this team in the match.")
            return []

    match_details = fetch_match_details(match_id)

    if match_details.empty is False:
        home_team_players = get_list_of_players(
            team_id=match_details["home_team_id"].iloc[0], match_id=match_id
        )
        away_team_players = get_list_of_players(
            team_id=match_details["away_team_id"].iloc[0], match_id=match_id
        )

        results = list()

        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            # Submit all tasks: map each future to its corresponding item
            future_to_item: dict[Future[T], Any] = {
                executor.submit(
                    fetch_player_stats, player_id=player_id, match_id=match_id
                ): player_id
                for player_id in home_team_players + away_team_players
            }

            # Collect results as they complete (not in submission order)
            for future in as_completed(future_to_item):
                item = future_to_item[future]
                try:
                    result = future.result()
                    results.append((item, result))
                    print(f"Successfully fetched data for item: {item}")
                except Exception as e:
                    # Exception already logged in _try_request, just capture here
                    print(f"Failed to fetch data for item: {item} with error: {e}")
                    results.append((item, e))

        # Combine all player stats DataFrames into a single DataFrame
        player_stats_list = [
            res[1] for res in results if isinstance(res[1], pd.DataFrame)
        ]
        if player_stats_list:
            all_player_stats = pd.concat(player_stats_list, ignore_index=True)
            return all_player_stats
        else:
            print("No player stats data available for this match.")
            return pd.DataFrame()
    else:
        print("No match details available.")
        return pd.DataFrame()

# %% ../nbs/match.ipynb #a375e024
def fetch_matches(date: str):
    print("Deprecated, please use the fetch_matches_by_date() function instead")
